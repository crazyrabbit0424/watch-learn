/*
第一行: 0
第二行: 01
第三行: 0110
第四行: 01101001
也就是随着行数增加，每次都把之前行的每个数字都一分为二。

第 N 行的第 K 个数字，是通过 N - 1 行的第 (K - 1) / 2 + 1) 个数字产生的。（因为K是从 1 开始的需要 -1）
(K - 1) / 2 + 1) == (k + 1) / 2 这俩是一样的

通过递归调用，肯定能够计算出这个数字。
如果 N - 1 行的数字是 0 ，那么产生 01 ，否则产生 10 。
*/
int kthGrammar(int N, int K){
    if ((1 == N) && (1 == K))
    {
        return 0;
    }
    
    int a = kthGrammar(N - 1, (K + 1)/2);
    int b = (a == 1) ? 0 : 1;
    if (K % 2 == 1)
    {
        return a;
    }
    else
    {
        return b;
    }
}
